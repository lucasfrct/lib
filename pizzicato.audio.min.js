! function (e) {"use strict"; função t (e, t) {this.options = {}, e = e || this.options; var i = {frequency: 350, peak: 1}; this. inputNode = this.filterNode = s.context.createBiquadFilter (), this.filterNode.type = t, this.outputNode = o.context.createGain (), this.filterNode.connect (this.outputNode); for (var n in i) this [n] = e [n], this [n] = void 0 === this [n] || null === this [n]? i [n]: this [n]} função i ( ) {var e, t, i = s.context.sampleRate * this.time, n = o.context.createBuffer (2, i, s.context.sampleRate), a = n.getChannelData (0), r = n .getChannelData (1); para (t = 0; i> t; t ++) e = this.reverse? it: t, a [t] = (2 * Math.random () - 1) * Math.pow (1 -e / i, este.decay), r [t] = (2 * Math.random () - 1) * Math.pow (1-e / i, este.decay); this.reverbNode.buffer = n} função n (e) {para (var t = s.context.sampleRate, i = novo Float32Array (t), n = Math.PI / 180, o = 0; t> o; o ++) {var a = 2 * o /t-1;i[o}=(3+e)*a*20*n/(Math.PI+e*Math.abs(a))}return i} var o = {}, s = o,a = "objeto" == tipo de módulo && module.exports, r = "função" == tipo de definição && define.amd; a? module.exports = o: r? define ([], o): e.Pizzicato = e.Pz = o; var c = e.AudioContext || e.webkitAudioContext; if (! c) retorna void console.error ("Nenhum AudioContext encontrado neste ambiente. Verifique se a sua janela ou objeto global contém uma função construtora do AudioContext em funcionamento."); o.context = new c; var h = o.context.createGain (); h.connect (o.context.destination), o.Util = {isString: function (e) {return "[object String]" == = toString.call (e)}, isObject: function (e) {return "[object Object]" === toString.call (e)}, isFunction: function (e) {return "[object Function]" == = toString.call (e)}, isNumber: function (e) {return "[Number do objeto]" === toString.call (e) && e === + e}, isArray: function (e) {return "[ matriz de objetos] "=== toString.call (e)}, isInRange: function (e, t, i) {return s.Util.isNumber (e) && s.Util.isNumber (t) && s.Util.isNumber (i)? e> = t && i> = e:! 1}, isBool: function (e) {return "boolean" == tipo de e}, isOscillator: function (e) {return e && "[object OscillatorNode]" === e.toString () }, isAudioBufferSourceNode: function (e) {return e && "[objeto AudioBufferSourceNode]" === e.toString ()}, isSound: function (e) {return e instanceof s.Sound}, isEffect: function (e) {for (var t em O.Effects) if (uma instância de o.Effects [t]) return! 0; return! 1}, normalize: function (e, t, i) {return s.Util.isNumber (e) && s. Util.isNumber (t) && s.Util.isNumber (i)? (It) * e / 1 + t: void 0}, getDryLevel: function (e) {return! S.Util.isNumber (e) || e> 1 || 0> e? 0: .5> = e? 1: 1-2 * (e-.5)}, getWetLevel: function (e) {return! S.Util.isNumber (e) || e> 1 || 0> e? 0: e> =.5? 1: 1-2 * (. 5-e)}}; var u = o.context.createGain (), d = Object.getPrototypeOf (Object.getPrototypeOf (u)), l = d.connect; d. connect = function (e) {var t = s.Util.isEffect (e)? e.inputNode: e; retorna l.call (this, t), e}, Object.defineProperty (o, "volume", {enumerável :! 0, get: function () {retornar h.gain.value}, defina: function (e) {s.Util.isInRange (e, 0,1) && h && (h.gain.value = e)}}) , Object.defineProperty (o, "masterGainNode", {enumerável:! 1, get: function () {return h}, defina: function (e) {console.error ("Não é possível definir o nó de ganho principal")} }), o.Events = {on: function (e, t, i) {if (e && t) {this._events = this._events || {}; var n = this._events [e] || (this. _events [e] = []); n.push ({retorno de chamada: t, contexto: i || isto, manipulador: isto})}}, trigger: function (e) {if (e) {var t, i, n, o; if (this._events = this._events || {}, t = this._events [e] || (this._events [e] = [])) {for (i = Math.max (0 argumentos.comprimento-1), n ​​= [], o = 0; i> o; o ++) n [o] = argumentos [o + 1]; para (o = 0; o <t.length; o ++) t [o] .callback.apply (t [o] .context, n)}}}, off: function (e) {e? this._events [e] = void 0: this._events = {}}}, o.Sound = função (e, t) {função i (e) {var t = ["onda", "arquivo", "entrada", "script", "som"]; if (e &&! d.isFunction (e) &&! d.isString (e) &&! d.isObject (e)) return "Tipo de descrição não suportado. Inicialize um som usando um objeto, uma função ou uma string."; if (d.isObject (e)) {if (! d.isString (e.source) || -1 === t.indexOf (e.source)) return "Fonte especificada não suportada. As fontes podem ser wave, arquivo, entrada ou script"; if (! ("file" ! == e.source || e.options && e.options.path)) return "É necessário um caminho para sons com uma fonte de arquivo"; if (! ("script"! == e.source || e.options && e. opçõesaudioFunction)) return "É necessária uma função de áudio para sons com uma fonte de script"}} função n (e, t) {e = e || {}, this.getRawSourceNode = function () {var t = this.sourceNode? this.sourceNode.frequency.value: e.frequency, i = o.context.createOscillator (); retorne i.type = e.type || "seno", i.frequency.value = t || 440, i}, this.sourceNode = this.getRawSourceNode (), this.sourceNode.gainSuccessor = s.context.createGain (), this.sourceNode.connect (this.sourceNode.gainSuccessor), função d.isFunction (t) && t ()} a ( e, t) {e = d.isArray (e)? e: [e]; var i = novo XMLHttpRequest; i.open ("GET", e [0] ,! 0), i.responseType = "arraybuffer" , i.onload = function (i) {o.context.decodeAudioData (i.target.response, function (e) {u.getRawSourceNode = function () {var t = o.context.createBufferSource (); return t.loop = this.loop, t.buffer = e, t}, função d.is (t) && t ()}. bind (u),função (i) {retorna console.error ("Erro ao decodificar arquivo de áudio" + e [0]), comprimento> 1? (e.shift (), anula a (e, t)) :( i = i | | new Error ("Erro ao decodificar o arquivo de áudio" + e [0]), void (d.isFunction (t) && t (i)))}. bind (u))}, i.onreadystatechange = function (t) {4 === i.readyState && 200! == i.status && console.error ("Erro ao buscar" + e [0] + "." + i.statusText)}, i.send ()} função r (e, t) { retornar navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia, navigator.getUserMedia? () {return o.context.createMediaStreamSource (e)}, d.isFunction (t) && t ()}. bind (u), função (e) {d.isFunction (t) && t (e)}): console nulo .error ("O seu navegador não suporta getUserMedia")} função c (e, t) {var i = função d.is (e)? e: função e.audio, n = d.isObject (e) && e.bufferSize? e.bufferSize: null; if (! n) try {o.context.createScriptProcessor ()} captura (s) {n = 2048} this.getRawSourceNode = function () {var e = o.context.createScriptProcessor (n, 1,1); return e.onaudioprocess = i, e }} função h (e, t) {this.getRawSourceNode = e.sound.getRawSourceNode, e.sound.sourceNode && s.Util.isOscillator (e.sound.sourceNode) && (this.sourceNode = this.getRawSourceNode (), this. frequência = e.sound.frequency)} var u = this, d = o.Util, l = i (e), f = d.isObject (e) && d.isObject (e.options), p = 0,04, v = .04; if (l) throw console.error (l), new Error ("Erro ao inicializar o Pizzicato Sound:" + l); this.detached = f && e.options.detached, this.masterVolume = o.context.createGain ( ), this.fadeNode = o.context.createGain (), this.fadeNode.gain.value = 0, this.detached || this.masterVolume.connect (o.masterGainNode), this.lastTimePlayed = 0, this.effects = [], this.effectConnectors = [], this.playing = this.paused =! 1, this.loop = f && e.options.loop, this. ataque = f && d.isNumber (e.options.attack)? e.options.attack: p, este.volume = f && d.isNumber (e.options.volume)? e.options.volume: 1, f &&.d.isNumber. options.release)? this.release = e.options.release: f && d.isNumber (e.options.sustain)? (console.warn ("'sustain' está obsoleto. Use 'release' em vez disso."), this.release = e.options.sustain): this.release = v, e? d.isString (e)? a.bind (this) (e, t): d.isFunction (e)? c.bind (this) (e , t): "arquivo" === e.source? a.bind (this) (e.options.path, t): "wave" === e.source? n.bind (this) (e.options , t): "input" === e.source? r.bind (this) (e, t): "script" === e.source? c.bind (this) (e.options, t): "som" === e.fonte && h.bind (this) (e.options, t): n.bind (this) ({}, t)}, o.Sound.prototype = Object.create (o.Events, {play: {enumerable:! 0 , value: function (e, t) {this.playing || (s.Util.isNumber (t) || (t = this.offsetTime || 0), s.Util.isNumber (e) || (e = 0), this.playing =! 0, this.paused =! 1, this.sourceNode = this.getSourceNode (), this.applyAttack (), s.Util.isFunction (this.sourceNode.start) && (this.lastTimePlayed = o.context.currentTime-t, this.sourceNode.start (s.context.currentTime + e, t)), this.trigger ("play"))}}, pare: {enumerável:! 0, valor: function () {(this.paused || this.playing) && (this.paused = this.playing =! 1, this.stopWithRelease (), this.offsetTime = 0, this.trigger ("stop"))}}, pausa: {enumerável:! 0, valor: function () {if (! this.paused && this.playing) {this.paused =! 0, this.playing =! 1, this.stopWithRelease (); var e = s.context .currentTime-this.lastTimePlayed; this.sourceNode.buffer? this.offsetTime = e% (this.sourceNode.buffer.length / s.context.sampleRate): this.offsetTime = e, this.trigger ("pausa")}}}, clone: ​​{enumerable :! 0, valor: function () {for (var e = new o.Sound ({source: "sound", opções: {loop: this.loop, attack: this.attack, release: this.attack, release: this.release, volume: this. volume, som: this}}), t = 0; t <this.effects.length; t ++) e.addEffect (this.effects [t]); return e}}, onEnded: {enumerable:! 0, value: function (e) {return function () {this.sourceNode && this.sourceNode! == e || (this.playing && this.stop (), this.paused || this.trigger ("end"))}}}, addEffect: {enumerable:! 0, value: function (e) {if (! s.Util.isEffect (e)) retorna console.error ("O objeto fornecido não é um efeito Pizzicato."), this; this.effects.push (e); var t = this.effectConnectors.length> 0? this.effectConnectors [this.effectConnectors.length-1]: this.Para obter mais informações, consulte a página de suporte da Microsoft.Para obter mais informações, consulte a página de suporte da Microsoft. ), this}}, removeEffect: {enumerável:! 0, valor: function (e) {var t = this.effects.indexOf (e); if (-1 === t) retorna console.warn ("Não é possível remover efeito que não é aplicado a esse som. "), this; var i = this.playing; i && this.pause (); var n = 0 === t? this.fadeNode: this.effectConnectors [t-1]; n .disconnect (); var o = this.effectConnectors [t]; o.disconnect (), e.disconnect (o), this.effectConnectors.splice (t, 1), this.effects.splice (t, 1); var s; return s = t> this.effects.length-1 || 0 === this.effects.length? this.masterVolume: this.effects [t], n.connect (s), i && this.play () , this}}, conecte: {enumerable:! 0, value: function (e) {retorne this.masterVolume.connect (e), this}}, desconecte: {enumerable:! 0, value: function (e) {return isto.masterVolume.disconnect (e), this}}, connectEffects: {enumerable:! 0, value: function () {for (var e = [], t = 0; t <this.effects.length; t ++) {var i = t === this.effects.length-1, n = i? this.masterVolume: this.effects [t + 1] .inputNode; e [t] = s.context.createGain (), this.effects [t ] .outputNode.disconnect (this.effectConnectors [t]), this.effects [t] .outputNode.connect (n)}}}, volume: {enumerável:! 0, get: function () {retornar this.masterVolume? this.masterVolume.gain.value: void 0}, defina: function (e) {s.Util.isInRange (e, 0,1) && this.masterVolume && (this.masterVolume.gain.value = e)}}, frequência: {enumerável:! 0, get: function () {retorna this.sourceNode && s.Util.isOscillator (this.sourceNode)? this.sourceNode.frequency.value: null}, defina: function (e) {this.sourceNode && s.Util. isOscillator (this.sourceNode) && (this.sourceNode.frequency.value = e)}}, sustain: {enumerable:! 0, get:function () {return console.warn ("'sustain' está obsoleto. Use 'release' em vez disso."), this.release}, set: function (e) {console.warn ("'sustain' está obsoleto. Use ' libere 'em vez disso. "), s.Util.isInRange (e, 0,10) && (this.release = e)}}, getSourceNode: {enumerável:! 0, valor: function () {if (this.sourceNode) {var e = this.sourceNode; por exemplo ,ainSuccessor.gain.setValueAtTime (por exemplo ,ainSuccessor.gain.value, s.context.currentTime), por exemplo ,ainSuccessor.gain.linearRampToValueAtTime (1e-4, s.context.currentTime + .2 ), setTimeout (function () {e.disconnect (), por exemplo ,ainuccessor.disconnect ()}, 200)} var t = this.getRawSourceNode (); return t.gainSuccessor = s.context.createGain (), t. conectar (t.gainSuccessor), t.gainSuccessor.connect (this.fadeNode), this.fadeNode.connect (this.getInputNode ()), s.Util.isAudioBufferSourceNode (t) && (t.onended = this.onEnded (t )bind (this)), t}}, getInputNode: {enumerable:! 0, value: function () {retorna this.effects.length> 0? this.effects [0] .inputNode: this.masterVolume}}, applyAttack: {enumerable:! 1, value: function () {var e = this.fadeNode.gain.value; if (this.fadeNode.gain.cancelScheduledValues ​​(s.context.currentTime), this.fadeNode.gain.setValueAtTime (e, s.context.currentTime) ,! this.attack) return void this.fadeNode.gain.setValueAtTime (1, o.context.currentTime); var t = (1-this.fadeNode.gain.value) * this.attack; this.fadeNode.gain.setValueAtTime (this.fadeNode.gain.value, o.context.currentTime), this.fadeNode.gain.linearRampToValueAtTime (1, o.context.currentTime + t)}}, stopWithRelease: {enumerable :! 1, valor: function (e) {var t = this.sourceNode, i = function () {return s.Util.isFunction (t.stop)? T.stop (0): t.disconnect ()}, n = this.fadeNode.gain.value; if (this.fadeNode.gain.cancelScheduledValues ​​(s.context.atualTime), this.fadeNode.gain.setValueAtTime (n, s.context.currentTime) ,! this.release) return void i (); var a = this.fadeNode.gain.value * this.release; this.fadeNode. ganho.setValueAtTime (this.fadeNode.gain.value, o.context.currentTime), this.fadeNode.gain.linearRampToValueAtTime (1e-5, o.context.currentTime + a), window.setTimeout (function () {i ( )}, 1e3 * a)}}}), o.Group = função (e) {e = e || [], this.mergeGainNode = s.context.createGain (), this.masterVolume = s.context.createGain (), this.sounds = [], this.effects = [], this.effectConnectors = [], this.mergeGainNode.connect (this.masterVolume), this.masterVolume.connect (s.masterGainNode); for (var t = 0; t <comprimento.de; t ++) this.addSound (e [t])}, o.Group.prototype = Object.create (s.Events, {connect: {enumerable:! 0, value: function (e ) {retorne this.masterVolume.connect (e), this}}, desconecte: {enumerável:! 0, valor: function (e) {retorne this.masterVolume.desconecte (e), isso}}, adicione Som: {enumerável:! 0, valor: função (e) {retorne s.Util.isSound (e)? this.sounds.indexOf (e)> - 1? void console.warn ("O objeto Pizzicato.Sound já foi adicionado a este grupo") :( e.detached && console.warn ("Os grupos não suportam sons desanexados. Você pode criar manualmente um gráfico de áudio para agrupar sons desanexados."), E.disconnect (s.masterGainNode), e.connect (this.mergeGainNode), anula this.sounds.push (e)): void console.error ("Você pode adicionar apenas objetos Pizzicato.Sound")}}, removeSound: {enumerable: ! 0, valor: function (e) {var t = this.sounds.indexOf (e); return-1 === t? Void console.warn ("Não é possível remover um som que não faz parte deste grupo.") : (e.disconnect (this.mergeGainNode), e.connect (s.masterGainNode), anula this.sounds.splice (t, 1))}}, volume: {enumerável:! 0, get: function () {return isto.masterVolume? this.masterVolume.gain.value: void 0}, defina: function (e) {s.Util.isInRange (e, 0,1) && (this.masterVolume.gain.value = e)}}, execute: {enumerable:! 0, value: function () {for (var e = 0; e <this.sounds.length; e ++) this.sounds [e] .play (); this.trigger ("play")}} , stop: {enumerable:! 0, value: function () {for (var e = 0; e <this.sounds.length; e ++) this.sounds [e] .stop (); this.trigger ("stop" )}}, pausa: {enumerável:! 0, valor: function () {for (var e = 0; e <this.sounds.length; e ++) this.sounds [e] .pause (); this.trigger ( "pausa")}}, addEffect: {enumerável:! 0, valor: function (e) {if (! s.Util.isEffect (e)) retorna console.error ("O objeto fornecido não é um efeito Pizzicato." ), this; this.effects.push (e); var t = this.effectConnectors.length> 0? this.effectConnectors [this.effectConnectors.length-1]: this.mergeGainNode; t.disconnect (), t.connect (e); vari = s.context.createGain (); retorna this.effectConnectors.push (i), e.connect (i), i.connect (this.masterVolume), this}}, removeEffect: {enumerable:! 0, value: function (e) {var t = this.effects.indexOf (e); if (-1 === t) retorna console.warn ("Não é possível remover o efeito que não é aplicado a este grupo."), this; var i = 0 == = t? this.mergeGainNode: this.effectConnectors (t-1); i.disconnect (); var n = this.effectConnectors [t]; n.disconnect (), e.disconnect (n), this.effectConnectors.splice (t, 1), isto.effects.splice (t, 1); var o; return o = t> this.effects.length-1 || 0 === this.effects.length? this.masterVolume: this. efeitos [t], i.connect (o), isso}}}), o.Effects = {}; var f = Object.create (null, {connect: {enumerable:! 0, value: function (e) { retornar this.outputNode.connect (e), this}}, desconectar: ​​{enumerable:! 0, value: function (e) {retornar this.outputNode.disconnect (e), this}}}); o.Effects.Delay = função (e) {this.options = {},e = e || this.options; var t = {feedback: .5, time: .3, mix: .5}; this.inputNode = o.context.createGain (), this.outputNode = o.context.createGain (), this.dryGainNode = o.context.createGain (), this.wetGainNode = o.context.createGain (), this.feedbackGainNode = o.context.createGain (), this.delayNode = o.context.createDelay () , this.inputNode.connect (this.dryGainNode), this.dryGainNode.connect (this.outputNode), this.delayNode.connect (this.feedbackGainNode), this.feedbackGainNode.connect (this.delayNode), this.inputNode.connect (this.delayNode), this.delayNode.connect (this.wetGainNode), this.wetGainNode.connect (this.outputNode); for (var i in t) this [i] = e [i], this [i] = void 0 === this [i] || null === this [i]? t [i]: this [i]}, o.Effects.Delay.prototype = Object.create (f, {mix: {enumerable :! 0, get: function () {retorne this.options.mix}, defina: function (e) {s.Util.isInRange (e, 0,1) && (this.options.mix = e, this.dryGainNode.gain.value = o.Util.getDryLevel (this.mix), this.wetGainNode.gain.value = o.Util.getWetLevel (this.mix))}}, hora: {enumerável:! 0, get: function () {retorne this.options.time}, defina: function (e) {s.Util.isInRange (e, 0,180) && (this.options.time = e, this.delayNode.delayTime.value = e)}} , feedback: {enumerável:! 0, get: function () {retorne this.options.feedback}, defina: function (e) {s.Util.isInRange (e, 0,1) && (this.options.feedback = parseFloat (e, 10), this.feedbackGainNode.gain.value = this.feedback)}}}), o.Effects.Compressor = função (e) {this.options = {}, e = e || this.options ; var t = {limite: -24, joelho: 30, ataque: 0,003, liberação: 0,25, proporção: 12}; this.inputNode = this.compressorNode = o.context.createDynamicsCompressor (), this.outputNode = o .context.createGain (), this.compressorNode.connect (this.outputNode); for (vari in t) this [i] = e [i], this [i] = void 0 === this [i] | | null === isto [i]? t [i]: isto [i]},o.Effects.Compressor.prototype = Object.create (f, {threshold: {enumerable:! 0, get: function () {retorne this.compressorNode.threshold.value}, defina: function (e) {o.Util. isInRange (e, -100,0) && (this.compressorNode.threshold.value = e)}}, joelho: {enumerável:! 0, get: function () {retorne this.compressorNode.knee.value}, defina: function (e) {o.Util.isInRange (e, 0,40) && (this.compressorNode.knee.value = e)}}, ataque: {enumerável:! 0, get: function () {retorne this.compressorNode .attack.value}, defina: function (e) {o.Util.isInRange (e, 0,1) && (this.compressorNode.attack.value = e)}}, release: {enumerable:! 0, get: function () {return this.compressorNode.release.value}, defina: function (e) {o.Util.isInRange (e, 0,1) && (this.compressorNode.release.value = e)}}, razão: {enumerável:! 0, get: function () {retorne this.compressorNode.ratio.value}, defina: function (e) {o.Util.isInRange (e, 1,20) && (this.compressorNode.ratio.value = e)}}, getCurrentGainReduction: function () {retorne this.compressorNode.reduction}}), o.Effects.LowPassFilter = function (e) {t.call (this, e, "lowpass") }, o.Effects.HighPassFilter = function (e) {t.call (this, e, "highpass")}; var p = Object.create (f, {frequência: {enumerável:! 0, get: function ()) {return this.filterNode.frequency.value}, defina: function (e) {o.Util.isInRange (e, 10.22050) && (this.filterNode.frequency.value = e)}}, pico: {enumerável: ! 0, get: function () {retorna this.filterNode.Q.value}, define: function (e) {o.Util.isInRange (e, 1e-4,1e3) && (this.filterNode.Q.value = e)}}}); o.Effects.LowPassFilter.prototype = p, o.Effects.HighPassFilter.prototype = p, o.Effects.Distortion = function (e) {this.options = {}, e = e || this.options; var t = {gain: .5}; this.waveShaperNode = o.context.createWaveShaper (), this.inputNode = this.outputNode = this.waveShaperNode;para (var i in t) isto [i] = e [i], isto [i] = nulo 0 === isto [i] || nulo === isto [i]? t [i]: isto [i ]}, o.Effects.Distortion.prototype = Object.create (f, {gain: {enumerable:! 0, get: function () {retorna this.options.gain}, defina: function (e) {s.Util .isInRange (e, 0,1) && (this.options.gain = e, this.adjustGain ())}}, AdjustGain: {gravável:! 1, configurável:! 1, enumerável:! 1, valor: function ( ) {for (var e, t = s.Util.isNumber (this.options.gain)? parseInt (100 * this.options.gain, 10): 50, i = 44100, n = new Float32Array (i), o = Math.PI / 180, a = 0; i> a; ++ a) e = 2 * a / i-1, n [a] = (3 + t) * e * 20 * o / (Math.PI + t * Math.abs (e)); this.waveShaperNode.curve = n}}}), o.Effects.Flanger = function (e) {this.options = {}, e = e || this.options; var t = {time: .45, speed: .2, depth: .1, feedback: .1, mix: .5}; this.inputNode = o.context.createGain (), this.outputNode = o.context. createGain (), this.inputFeedbackNode = o.context.createGain (), this.wetGainNode = o.context.createGain (), this.dryGainNode = o.context.createGain (), this.delayNode = o.context.createDelay (), this.oscillatorNode = o.context.createOscillator (), this.gainNode = o.context.createGain ( ), this.feedbackNode = o.context.createGain (), this.oscillatorNode.type = "seno", this.inputNode.connect (this.inputFeedbackNode), this.inputNode.connect (this.dryGainNode), this.inputFeedbackNode. conectar (this.delayNode), this.inputFeedbackNode.connect (this.wetGainNode), this.delayNode.connect (this.wetGainNode), this.delayNode.connect (this.feedbackNode), this.feedbackNode.connect (this.inputFeedbackNode) , this.oscillatorNode.connect (this.gainNode), this.gainNode.connect (this.delayNode.delayTime), this.dryGainNode.connect (this.outputNode), this.wetGainNode.connect (this.outputNode), this.oscillatorNode .start (0); para (var i in t) this [i] = e [i], this [i] = void 0 === this [i] || null === this [i]? t [ Eu]:this [i]}, o.Effects.Flanger.prototype = Object.create (f, {time: {enumberable:! 0, get: function () {retorne this.options.time}, defina: function (e) { s.Util.isInRange (e, 0,1) && (this.options.time = e, this.delayNode.delayTime.value = s.Util.normalize (e, .001, .02))}}, velocidade: {enumerável:! 0, get: function () {retorna this.options.speed}, defina: function (e) {s.Util.isInRange (e, 0,1) && (this.options.speed = e, este .oscillatorNode.frequency.value = s.Util.normalize (e, .5,5))}}, profundidade: {enumerável:! 0, get: function () {retorne this.options.depth}, defina: function ( e) {s.Util.isInRange (e, 0,1) && (this.options.depth = e, this.gainNode.gain.value = s.Util.normalize (e, 5e-4, .005))} }, feedback: {enumerável:! 0, get: function () {retorna this.options.feedback}, define: function (e) {s.Util.isInRange (e, 0,1) && (this.options.feedback = e, this.feedbackNode.gain.value = s.Util.normalize (e, 0, .8))}}, misture: {enumberable :!0, get: function () {retorna this.options.mix}, defina: function (e) {s.Util.isInRange (e, 0,1) && (this.options.mix = e, this.dryGainNode.gain .value = o.Util.getDryLevel (this.mix), this.wetGainNode.gain.value = o.Util.getWetLevel (this.mix))}}}), o.Effects.StereoPanner = function (e) {this .options = {}, e = e || this.options; var t = {pan: 0}; this.inputNode = o.context.createGain (), this.outputNode = o.context.createGain (), o. context.createStereoPanner? (this.pannerNode = o.context.createStereoPanner (), this.inputNode.connect (this.pannerNode), this.pannerNode.connect (this.outputNode)): this.inputNode.connect (this.outputNode) ; para (var i in t) this [i] = e [i], this [i] = void 0 === this [i] || null === this [i]? t [i]: this [ i]}, o.Effects.StereoPanner.prototype = Object.create (f, {pan: {enumerável:! 0, get: function () {retorna this.options.pan}, define: function (e) {s. Util.isInRange (e, -1,1) && (this.options.pan = e, this.pannerNode && (this.pannerNode.pan.value = e))}}}), o.Effects.Convolver = function (e, t) {this.options = {}, e = e || this.options; var i = Isso, n = novo XMLHttpRequest, a = {mix: .5}; this.callback = t, this.inputNode = o.context.createGain (), this.convolverNode = o.context.createConvolver (), this.outputNode = o.context.createGain (), this.wetGainNode = o.context.createGain (), this.dryGainNode = o.context.createGain (), this.inputNode.connect (this.convolverNode), this.convolverNode.connect (this .wetGainNode), this.inputNode.connect (this.dryGainNode), this.dryGainNode.connect (this.outputNode), this.wetGainNode.connect (this.outputNode); para (var r in a) this [r] = e [r], isto [r] = nulo 0 === isto [r] || nulo === isto [r]? a [r]: isto [r]; return e.impulse? (n.open (" GET ", e.impulse,! 0), n.responseType =" arraybuffer ", n.onload = function (e) {var t = e.target.response; o.context.decodeAudioData (t,function (e) {i.convolverNode.buffer = e, i.callback && s.Util.isFunction (i.callback) && i.callback ()}, função (e) {e = e || new Error ("Erro ao decodificar o arquivo de impulso "), i.callback && s.Util.isFunction (i.callback) && i.callback (e)})}, n.onreadystatechange = function (t) {4 === n.readyState && 200! == n.status && console.error ( "Erro ao buscar" + e.impulse + "." + N.statusText)}, void n.send ()): void console.error ("Nenhum arquivo de impulso especificado.")}, O.Effects.Convolver.prototype = Object.create (f, {mix: {enumerável:! 0, get: function () {retorna this.options.mix}, defina: function (e) {s.Util.isInRange (e, 0,1) && ( this.options.mix = e, this.dryGainNode.gain.value = o.Util.getDryLevel (this.mix), this.wetGainNode.gain.value = o.Util.getWetLevel (this.mix))}}}) , o.Effects.PingPongDelay = function (e) {this.options = {}, e = e || this.opções; var t = {feedback: .5, time: .3, mix: .5}; this.inputNode = o.context.createGain (), this.outputNode = o.context.createGain (), this.delayNodeLeft = o.context.createDelay (), this.delayNodeRight = o.context.createDelay (), this.dryGainNode = o.context.createGain (), this.wetGainNode = o.context.createGain (), this.feedbackGainNode = o. context.createGain (), this.channelMerger = o.context.createChannelMerger (2), this.inputNode.connect (this.dryGainNode), this.dryGainNode.connect (this.outputNode), this.delayNodeLeft.connect (this.channelMerger) , 0,0), this.delayNodeRight.connect (this.channelMerger, 0,1), this.delayNodeLeft.connect (this.delayNodeRight), this.feedbackGainNode.connect (this.delayNodeLeft), this.delayNodeRight.connect (this .feedbackGainNode), this.inputNode.connect (this.feedbackGainNode), this.channelMerger.connect (this.wetGainNode), this.wetGainNode.connect (this.outputNode);para (var i in t) isto [i] = e [i], isto [i] = nulo 0 === isto [i] || nulo === isto [i]? t [i]: isto [i ]}, o.Effects.PingPongDelay.prototype = Object.create (f, {mix: {enumerável:! 0, get: function () {retorna this.options.mix}, defina: function (e) {s.Util .isInRange (e, 0,1) && (this.options.mix = e, this.dryGainNode.gain.value = o.Util.getDryLevel (this.mix), this.wetGainNode.gain.value = o.Util. getWetLevel (this.mix))}}, hora: {enumerável:! 0, get: function () {retorne this.options.time}, defina: function (e) {s.Util.isInRange (e, 0,180) && (this.options.time = e, this.delayNodeLeft.delayTime.value = e, this.delayNodeRight.delayTime.value = e)}}, feedback: {enumerável:! 0, get: function () {retorna this.options .feedback}, defina: function (e) {s.Util.isInRange (e, 0,1) && (this.options.feedback = parseFloat (e, 10), this.feedbackGainNode.gain.value = this.feedback) }}}), o.Effects.Reverb = function (e) {this.options = {}, e = e || this.opções; var t = {mix: .5, tempo: .01, decaimento: .01, reverso:! 1}; this.inputNode = o.context.createGain (), this.reverbNode = o.context.createConvolver () , this.outputNode = o.context.createGain (), this.wetGainNode = o.context.createGain (), this.dryGainNode = o.context.createGain (), this.inputNode.connect (this.reverbNode), this. reverbNode.connect (this.wetGainNode), this.inputNode.connect (this.dryGainNode), this.dryGainNode.connect (this.outputNode), this.wetGainNode.connect (this.outputNode); para (var n in t) this [n] = e [n], este [n] = nulo 0 === isto [n] || nulo === isto [n]? t [n]: isto [n]; i.bind (this) ()}, o.Effects.Reverb.prototype = Object.create (f, {mix: {enumerável:! 0, get: function () {retorna this.options.mix}, defina: function (e) {s. Util.isInRange (e, 0,1) && (this.options.mix = e, this.dryGainNode.gain.value = o.Util.getDryLevel (this.mix), this.wetGainNode.gain.value = o.Util .getWetLevel (this.mix))}}, hora:{enumerável:! 0, get: function () {retorne this.options.time}, defina: function (e) {s.Util.isInRange (e, 1e-4,10) && (this.options.time = e , i.bind (this) ())}}, decaimento: {enumerável:! 0, get: function () {retorne this.options.decay}, defina: function (e) {s.Util.isInRange (e, 1e-4,10) && (this.options.decay = e, i.bind (this) ())}}, inverter: {enumerável:! 0, get: function () {retornar this.options.reverse}, set: function (e) {s.Util.isBool (e) && (this.options.reverse = e, i.bind (this) ())}}}), o.Effects.Tremolo = function (e) { this.options = {}, e = e || this.options; var t = {speed: 4, depth: 1, mix: .8}; this.inputNode = o.context.createGain (), this.outputNode = o.context.createGain (), this.dryGainNode = o.context.createGain (), this.wetGainNode = o.context.createGain (), this.tremoloGainNode = o.context.createGain (), this.tremoloGainNode.gain. valor = 0, this.lfoNode = o.context.createOscillator (), this.shaperNode = o.context.createWaveShaper (), this.shaperNode.curve = new Float32Array ([0,1]), this.shaperNode.connect (this.tremoloGainNode.gain), this.inputNode.connect (this.dryGainNode), this.dryGainNode.connect ( this.outputNode), this.lfoNode.connect (this.shaperNode), this.lfoNode.type = "sine", this.lfoNode.start (0), this.inputNode.connect (this.tremoloGainNode), this.tremoloGainNode. conectar (this.wetGainNode), this.wetGainNode.connect (this.outputNode); para (var i in t) this [i] = e [i], this [i] = void 0 === this [i] | | null === this [i]? t [i]: this [i]}, o.Effects.Tremolo.prototype = Object.create (f, {mix: {enumerável:! 0, get: function () { retorne this.options.mix}, defina: function (e) {s.Util.isInRange (e, 0,1) && (this.options.mix = e, this.dryGainNode.gain.value = o.Util.getDryLevel (this.mix), this.wetGainNode.gain.value = o.Util.getWetLevel (this.mix))}}, velocidade: {enumerável:! 0, get: function () {retorna this.options.velocidade}, defina: função (e) {s.Util.isInRange (e, 0,20) && (this.options.speed = e, this.lfoNode.frequency.value = e)}}, profundidade: {enumerable: ! 0, get: function () {retorna this.options.depth}, defina: function (e) {s.Util.isInRange (e, 0,1) && (this.options.depth = e, this.shaperNode. curva = nova Float32Array ([1-e, 1]))}}}), o.Effects.DubDelay = function (e) {this.options = {}, e = e || this.options; var t = { feedback: .6, time: .7, mix: .5, cutoff: 700}; this.inputNode = o.context.createGain (), this.outputNode = o.context.createGain (), this.dryGainNode = o. context.createGain (), this.wetGainNode = o.context.createGain (), this.feedbackGainNode = o.context.createGain (), this.delayNode = o.context.createDelay (), this.bqFilterNode = o.context. createBiquadFilter (), this.inputNode.connect (this.dryGainNode), this.dryGainNode.connect (this.outputNode), this.inputNode.connect (this.wetGainNode), this.inputNode.connect (this.feedbackGainNode), this.feedbackGainNode.connect (this.bqFilterNode), this.bqFilterNode.connect (this.delayNode), this.delayNode.connect (this.feedbackGainNode), this.delayNode.connect (this.wetGainNode), this.wetGainNode). .connect (this.outputNode); para (var i in t) this [i] = e [i], this [i] = void 0 === this [i] || null === this [i]? t [i]: this [i]}, o.Effects.DubDelay.prototype = Object.create (f, {mix: {enumerable:! 0, get: function () {retorne this.options.mix}, defina: função (e) {s.Util.isInRange (e, 0,1) && (this.options.mix = e, this.dryGainNode.gain.value = o.Util.getDryLevel (this.mix), this.wetGainNode. gain.value = o.Util.getWetLevel (this.mix))}}, hora: {enumerável:! 0, get: function () {retorne this.options.time}, defina: function (e) {s.Util .isInRange (e, 0,180) && (this.options.time = e, this.delayNode.delayTime.value = e)}}, feedback: {enumerável:! 0, get: function () {return this.options.feedback },conjunto:função (e) {s.Util.isInRange (e, 0,1) && (this.options.feedback = parseFloat (e, 10), this.feedbackGainNode.gain.value = this.feedback)}}, ponto de corte: { enumerável:! 0, get: function () {retorne this.options.cutoff}, defina: function (e) {s.Util.isInRange (e, 0,4e3) && (this.options.cutoff = e, this. bqFilterNode.frequency.value = this.cutoff)}}}), o.Effects.RingModulator = function (e) {this.options = {}, e = e || this.options; var t = {speed: 30, distorção: 1, mix: .5}; this.inputNode = o.context.createGain (), this.outputNode = o.context.createGain (), this.dryGainNode = o.context.createGain (), this.wetGainNode = o.context.createGain (), this.vIn = o.context.createOscillator (), this.vIn.start (0), this.vInGain = o.context.createGain (), this.vInGain.gain.value =. 5, this.vInInverter1 = o.context.createGain (), this.vInInverter1.gain.value = -1, this.vInInverter2 = o.context.createGain (), this.vInInverter2.gain.value = -1, este.vInDiode1 = novo v (o.context), this.vInDiode2 = novo v (o.context), this.vInInverter3 = o.context.createGain (), this.vInInverter3.gain.value = -1, this.vcInverter1 = o .context.createGain (), this.vcInverter1.gain.value = -1, this.vcDiode3 = new v (o.context), this.vcDiode4 = new v (o.context), this.outGain = o.context. createGain (), this.outGain.gain.value = 3, this.compressor = o.context.createDynamicsCompressor (), this.compressor.threshold.value = -24, this.compressor.ratio.value = 16, this.inputNode .connect (this.dryGainNode), this.dryGainNode.connect (this.outputNode), this.inputNode.connect (this.vcInverter1), this.inputNode.connect (this.vcDiode4.node), this.vcInverter1.connect (this .vcDiode3.node), this.vIn.connect (this.vInGain), this.vInGain.connect (this.vInInverter1), this.vInGain.connect (this.vcInverter1), this.vInGain.connect (this.vcDiode4.node ), this.vInInverter1.connect (this.vInInverter2), this.vInInverter1.connect (this.vInDiode2.node), this.vInInverter2.connect (this.vInDiode1.node), this.vInDiode1.connect (this.vInInverter3), this.vInDiode2.connect (this.vInInverter3), this.vInverter3. connect (this.compressor), this.vcDiode3.connect (this.compressor), this.vcDiode4.connect (this.compressor), this.compressor.connect (this.outGain), this.outGain.connect (this.wetGainNode) , this.wetGainNode.connect (this.outputNode); para (var i in t) this [i] = e [i], this [i] = void 0 === this [i] || null === this [i]? t [i]: this [i]}; var v = function (e) {this.context = e, this.node = this.context.createWaveShaper (), this.vb = .2, this. vl = .4, this.h = 1, this.setCurve ()}; retorne v.prototype.setDistortion = função (e) {retorne this.h = e, this.setCurve ()}, v.prototype.setCurve = função () {var e, t, i, n, o, s, a, r; for (t = 1024, o = new Float32Array (t), e = s = 0, a = o.length; a> = Qual é a raiz quadrada de 2? (X / 2) / (x / 2) / (x / 2) / x / 2Eu = Math.abs (i), n = i <= this.vb? 0: this.vb <i && i <= this.vl? this.h * (Math.pow (i-this.vb, 2) / ( 2 * this.vl-2 * this.vb)): this.h * i-this.h * this.vl + this.h * (Math.pow (this.vl-this.vb, 2) / (2) * this.vl-2 * this.vb)), o [e] = n; retorno r = this.node.curve = o}, v.prototype.connect = function (e) {
retornar this.node.connect (e)}, o.Effects.RingModulator.prototype = Object.create (f, {mix: {enumerable:! 0, get: function () {retorne this.options.mix}, defina: função (e) {s.Util.isInRange (e, 0,1) && (this.options.mix = e, this.dryGainNode.gain.value = o.Util.getDryLevel (this.mix), this.wetGainNode. gain.value = o.Util.getWetLevel (this.mix))}}, velocidade: {enumerável:! 0, get: function () {retorne this.options.speed}, defina: function (e) {s.Util .isInRange (e, 0,2e3) && (this.options.speed = e, this.vIn.frequency.value = e)}}, distorção: {enumerável:! 0, get: function () {retorna this.options .distortion}, defina: function (e) {if (s.Util.isInRange (e, .2,50)) {this.options.distortion = parseFloat (e, 10); for (var t = [this.vInDiode1 , this.vInDiode2, this.vcDiode3, this.vcDiode4], i = 0, n = comprimento.n> i; i ++) t [i] .setDistortion (e)}}}}), o.Effects.Quadrafuzz = função (e) {this.options = {}, e = e || this.options; var t = {lowGain: .6,midLowGain: .8, midHighGain: .5, highGain: .6}; this.inputNode = s.context.createGain (), this.outputNode = s.context.createGain (), this.dryGainNode = s.context.createGain ( ), this.wetGainNode = s.context.createGain (), this.lowpassLeft = s.context.createBiquadFilter (), this.lowpassLeft.type = "lowpass", this.lowpassLeft.frequency.value = 147, this.lowpassLeft. Q.value = .7071, this.bandpass1Left = s.context.createBiquadFilter (), this.bandpass1Left.type = "bandpass", this.bandpass1Left.frequency.value = 587, this.bandpass1Left.Q.value = .7071, this.bandpass2Left = s.context.createBiquadFilter (), this.bandpass2Left.type = "bandpass", this.bandpass2Left.frequency.value = 2490, this.bandpass2Left.Q.value = .7071, this.highpassLeft = s.context .createBiquadFilter (), this.highpassLeft.type = "highpass", this.highpassLeft.frequency.value = 4980, this.highpassLeft.Q.value = .7071,this.overdrives = []; para (var i = 0; 4> i; i ++) this.overdrives [i] = s.context.createWaveShaper (), this.overdrives [i] .curve = n (); this. inputNode.connect (this.wetGainNode), this.inputNode.connect (this.dryGainNode), this.dryGainNode.connect (this.outputNode); var o = [this.lowpassLeft, this.bandpass1Left, this.bandpass2Left, this.highpassLeft ]; para (i = 0; i <comprimento.i ++) this.wetGainNode.connect (o [i]), o [i] .connect (this.overdrives [i]), this.overdrives [i]. connect (this.outputNode); para (var a in t) this [a] = e [a], this [a] = void 0 === this [a] || null === this [a]? t [a]: este [a]}, o.Effects.Quadrafuzz.prototype = Object.create (f, {lowGain: {enumerable:! 0, get: function () {retorne this.options.lowGain}, defina: function (e) {s.Util.isInRange (e, 0,1) && (this.options.lowGain = e, this.overdrives [0] .curve = n (s.Util.normalize (this.lowGain, 0,150)) )}}, midLowGain: {enumerável:! 0, get: function () {retorna this.options.midLowGain}, defina: function (e) {s.Util.isInRange (e, 0,1) && (this.options.midLowGain = e, this.overdrives [1] .curve = n (s.Util.normalize (this .midLowGain, 0,150))}}, midHighGain: {enumerável:! 0, get: function () {retorna this.options.midHighGain}, set: function (e) {s.Util.isInRange (e, 0,1 ) && (this.options.midHighGain = e, this.overdrives [2] .curve = n (s.Util.normalize (this.midHighGain, 0,150)))}}}, highGain: {enumerable:! 0, get: function () {retornar this.options.highGain}, defina: function (e) {s.Util.isInRange (e, 0,1) && (this.options.highGain = e, this.overdrives [3] .curve = n (s.Util.normalize (this.highGain, 0,150)))}}}), o} ("indefinido"! = tipo de janela? janela: global);function () {retorne this.options.midHighGain}, defina: function (e) {s.Util.isInRange (e, 0,1) && (this.options.midHighGain = e, this.overdrives [2] .curve = n (s.Util.normalize (this.midHighGain, 0,150)))}}, highGain: {enumerável:! 0, get: function () {retorne this.options.highGain}, defina: function (e) {s. Util.isInRange (e, 0,1) && (this.options.highGain = e, this.overdrives [3] .curve = n (s.Util.normalize (this.highGain, 0,150)))}}}), o} ("indefinido"! = tipo de janela? janela: global);function () {retorne this.options.midHighGain}, defina: function (e) {s.Util.isInRange (e, 0,1) && (this.options.midHighGain = e, this.overdrives [2] .curve = n (s.Util.normalize (this.midHighGain, 0,150)))}}, highGain: {enumerável:! 0, get: function () {retorne this.options.highGain}, defina: function (e) {s. Util.isInRange (e, 0,1) && (this.options.highGain = e, this.overdrives [3] .curve = n (s.Util.normalize (this.highGain, 0,150)))}}}), o} ("indefinido"! = tipo de janela? janela: global);undefined "! = typeof window? window: global);undefined "! = typeof window? window: global);